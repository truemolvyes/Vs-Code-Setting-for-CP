{
	"Number Pi": {
		"prefix": "number_pi",
		"body": [
			"const long double PI = 4.1415926535897932384626433832795;"
		]
	},
	"Binpow": {
		"prefix": "binpow",
		"body": [
			"ll binpow(ll a, ll b) {",
			"    if (b == 0) return 1;",
			"    else if (b % 2 != 0) return (a%MOD * binpow(a, b-1)%MOD)%MOD;",
			"    ll tmp = binpow(a, b/2); return (tmp%MOD*tmp%MOD)%MOD;",
			"}"
		]
	},
	"Pragma for optimiz": {
		"prefix": "pragma_opt",
		"body": [
			"#pragma GCC optimize(\"O3,unroll-loops\")",
			"#pragma GCC target(.\"avx2,bmi,bmi2,lzcnt,popcnt\")",
			"#pragma GCC optimize(\"Ofast\")"
		]
	},
	"Ordered set": {
		"prefix": "ordered_set",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"typedef tree<long long, null_type, less<long long>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;"
		]
	},
	"Erase hepl": {
		"prefix": "erase_help",
		"body": [
			"/*",
			"str --  a.erase(index nachala , kolichesvo simvolov);",
			"set -- a.erase(iterator);",
			"deque , vector -- a.erase(a.begin + index nachala , a.begin + index konca + 1);",
			"*/"
		]
	},
	"Ordered set hepl": {
		"prefix": "ordered_set_help",
		"body": [
			"// order_of_key(k) : возвращает количество элементов, которые строго меньше нашего элемента k за время O(logn).",
			"// find_by_order(k) : возвращает итератор к k-му элементу (считая от нуля) в наборе за время O(logn)."
		]
	},
	"Segment Tree for Sum": {
		"prefix": "segment_tree_for_sum",
		"body": [
			"struct segment_tree{",
			"    struct segment{",
			"        ll left = 0, right = 0, sum = 0;",
			"    };",
			"",
			"    vector <segment> tree;",
			"",
			"    void build(ll n, ll arr[${1:/*Write the array length*/}]) {",
			"        ll n2 = n;",
			"        n = powl(2, ceil(log(n) / log(2)));",
			"        tree.resize(2*n);",
			"",
			"        for (ll i=n; i<2*n; i++) {",
			"            tree[i].left = i-n+1;",
			"            tree[i].right = i-n+1;",
			"            if (i-n+1 <= n2) {",
			"                tree[i].sum = arr[i-n+1];",
			"            }",
			"            else {",
			"                tree[i].sum = 0;",
			"            }",
			"        }",
			"",
			"        for (ll i=n-1; i>=1; i--) {",
			"            tree[i].left = tree[i*2].left;",
			"            tree[i].right = tree[i*2+1].right;",
			"            tree[i].sum = tree[i*2].sum + tree[i*2+1].sum;",
			"        }",
			"    }",
			"",
			"    void updata(ll change_value, ll need_to_change, ll location = 1) {",
			"        if (tree[location].left > need_to_change || tree[location].right < need_to_change) {",
			"            return;",
			"        }",
			"        else if (tree[location].left == need_to_change && tree[location].right == need_to_change) {",
			"            tree[location].sum = change_value;",
			"            return;",
			"        }",
			"        else {",
			"            updata(change_value, need_to_change, location*2);",
			"            updata(change_value, need_to_change, location*2+1);",
			"        }",
			"",
			"        tree[location].sum = tree[location*2].sum + tree[location*2+1].sum;",
			"    }",
			"",
			"    ll find_sum(ll left_bord, ll right_bord, ll location = 1) {",
			"        if (tree[location].left > right_bord || tree[location].right < left_bord) {",
			"            return 0;",
			"        }",
			"        else if (tree[location].left >= left_bord && tree[location].right <= right_bord) {",
			"            return tree[location].sum;",
			"        }",
			"        else {",
			"            ll sum_left = find_sum(left_bord, right_bord, location*2);",
			"            ll sum_rigt = find_sum(left_bord, right_bord, location*2+1);",
			"",
			"            return sum_left + sum_rigt;",
			"        }",
			"    }",
			"};"
		]
	},
	"Segment Tree for Max and Min": {
		"prefix": "segment_tree_for_min_max",
		"body": [
			"struct segment_tree{",
			"    struct segment{",
			"        ll left = 0, right = 0, mn = 1e18, mx = -1e18;",
			"    };",
			"",
			"    vector <segment> tree;",
			"",
			"    void build(ll n, ll arr[${1:/*Write the array length*/}]) {",
			"        ll n2 = n;",
			"        n = powl(2, ceil(log(n) / log(2)));",
			"        tree.resize(2*n);",
			"",
			"        for (ll i=n; i<2*n; i++) {",
			"            tree[i].left = i-n+1;",
			"            tree[i].right = i-n+1;",
			"            if (i-n+1 <= n2) {",
			"                tree[i].mn = arr[i-n+1];",
			"                tree[i].mx = arr[i-n+1];",
			"            }",
			"            else {",
			"                tree[i].mn = 1e18;",
			"                tree[i].mx = -1e18;",
			"            }",
			"        }",
			"",
			"        for (ll i=n-1; i>=1; i--) {",
			"            tree[i].left = tree[i*2].left;",
			"            tree[i].right = tree[i*2+1].right;",
			"            tree[i].mn = min(tree[i*2].mn, tree[i*2+1].mn);",
			"            tree[i].mx = max(tree[i*2].mx, tree[i*2+1].mx);",
			"        }",
			"    }",
			"",
			"    void updata(ll change_value, ll need_to_change, ll location = 1) {",
			"        if (tree[location].left > need_to_change || tree[location].right < need_to_change) {",
			"            return;",
			"        }",
			"        else if (tree[location].left == need_to_change && tree[location].right == need_to_change) {",
			"            tree[location].mn = change_value;",
			"            tree[location].mx = change_value;",
			"            return;",
			"        }",
			"        else {",
			"            updata(change_value, need_to_change, location*2);",
			"            updata(change_value, need_to_change, location*2+1);",
			"        }",
			"",
			"        tree[location].mn = min(tree[location*2].mn, tree[location*2+1].mn);",
			"        tree[location].mx = max(tree[location*2].mx, tree[location*2+1].mx);",
			"    }",
			"",
			"    ll find_min(ll left_bord, ll right_bord, ll location = 1) {",
			"        if (tree[location].left > right_bord || tree[location].right < left_bord) {",
			"            return 1e18;",
			"        }",
			"        else if (tree[location].left >= left_bord && tree[location].right <= right_bord) {",
			"            return tree[location].mn;",
			"        }",
			"        else {",
			"            ll min_left = find_min(left_bord, right_bord, location*2);",
			"            ll min_rigt = find_min(left_bord, right_bord, location*2+1);",
			"",
			"            return min(min_left, min_rigt);",
			"        }",
			"    }",
			"",
			"    ll find_max(ll left_bord, ll right_bord, ll location = 1) {",
			"        if (tree[location].left > right_bord || tree[location].right < left_bord) {",
			"            return -1e18;",
			"        }",
			"        else if (tree[location].left >= left_bord && tree[location].right <= right_bord) {",
			"            return tree[location].mx;",
			"        }",
			"        else {",
			"            ll max_left = find_max(left_bord, right_bord, location*2);",
			"            ll max_rigt = find_max(left_bord, right_bord, location*2+1);",
			"",
			"            return max(max_left, max_rigt);",
			"        }",
			"    }",
			"};"
		]
	}
}
